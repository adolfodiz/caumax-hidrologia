import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import Polygon, FancyArrowPatch
# --- Funciones auxiliares para dibujar ---
def draw_fixed_support(ax, x_pos, scale=1.0):
"""Dibuja un apoyo empotrado en la posición x_pos."""
height = 0.5 * scale
ax.plot([x_pos, x_pos], [-height, height], 'k-', lw=2)
for y in np.linspace(-height, height, 7):
ax.plot([x_pos, x_pos - height/2], [y, y - height/2], 'k-')
def draw_pinned_support(ax, x_pos, scale=1.0):
"""Dibuja un apoyo fijo/móvil (triángulo) en la posición x_pos."""
height = 0.4 * scale
width = 0.25 * scale
triangle = Polygon([[x_pos, 0], [x_pos - width, -height], [x_pos + width, -height]], facecolor='lightgray', edgecolor='k')
ax.add_patch(triangle)
def draw_distributed_load(ax, x_start, x_end, q_start, q_end, scale=0.3):
"""Dibuja una carga distribuida (trapezoidal/triangular)."""
y_offset = 0.3
y_start_pos = y_offset + q_start * scale
y_end_pos = y_offset + q_end * scale
# Dibuja el contorno de la carga
ax.plot([x_start, x_end], [y_start_pos, y_end_pos], 'r-')
ax.plot([x_start, x_start], [y_offset, y_start_pos], 'r-')
ax.plot([x_end, x_end], [y_offset, y_end_pos], 'r-')
# Rellena el área
ax.fill_between([x_start, x_end], [y_start_pos, y_end_pos], y2=y_offset, color='red', alpha=0.3)
# Dibuja las flechas de la carga
for x_arrow in np.linspace(x_start, x_end, 10):
q_interp = q_start + (q_end - q_start) * (x_arrow - x_start) / (x_end - x_start)
# --- CONDICIÓN AÑADIDA ---
# Solo dibuja la flecha si la magnitud de la carga en ese punto es significativa (no es cero)
if q_interp > 1e-6:
ax.arrow(x_arrow, y_offset + q_interp*scale, 0, -q_interp*scale, head_width=0.3, head_length=0.1, fc='r', ec='r')
# --- FIN DE LA MODIFICACIÓN ---
ax.text((x_start+x_end)/2, y_offset + max(q_start, q_end)*scale + 0.2, f'{max(q_start,q_end)}', ha='center', color='black')
def draw_point_load(ax, x_pos, magnitude, scale=1.5):
"""Dibuja una carga puntual."""
y_offset = 0.3
ax.arrow(x_pos, y_offset + scale, 0, -scale, head_width=0.4, head_length=0.2, fc='r', ec='r', lw=1.5)
ax.text(x_pos, y_offset + scale + 0.2, f'{abs(magnitude)}', ha='center', color='black')
def draw_reaction_force(ax, x_pos, magnitude):
"""Dibuja una flecha de reacción de fuerza con texto claro."""
if abs(magnitude) < 1e-6: return
direction = np.sign(magnitude)
arrow_length = 0.6
ax.arrow(x_pos, 0, 0, arrow_length * direction, head_width=0.4, head_length=0.2, fc='purple', ec='purple', lw=1.5)
text_y_offset = 0.1 * direction
vertical_alignment = 'bottom' if direction > 0 else 'top'
ax.text(x_pos, (arrow_length * direction) + text_y_offset, f'{magnitude:.2f}', ha='center', va=vertical_alignment, color='purple')
def draw_fancy_moment(ax, x_pos, magnitude, scale=0.5, color='g', linestyle='--'):
"""Dibuja un momento curvo con estilo mejorado y texto sin solapamiento."""
if abs(magnitude) < 1e-6: return
if magnitude > 0: # Anti-horario (positivo)
start_pos, end_pos = (x_pos + scale, 0.05), (x_pos - scale, 0.05)
else: # Horario (negativo)
start_pos, end_pos = (x_pos - scale, 0.05), (x_pos + scale, 0.05)
arrow = FancyArrowPatch(start_pos, end_pos, connectionstyle=f"arc3,rad={0.8}", color=color,
arrowstyle='->,head_length=5,head_width=3', lw=1.5, ls=linestyle)
ax.add_patch(arrow)
# Desplaza horizontalmente el texto del momento para evitar colisiones
text_x_pos = x_pos + scale * 0.6
ax.text(text_x_pos, scale * 0.6, f'{magnitude:.2f}', ha='left', va='center', color=color)
# --- Función Principal ---
def viga_rigidez(longitudes, E, I, cargas_dist, cargas_punt, apoyos):
n_tramos = len(longitudes)
n_nudos = n_tramos + 1
n_gdl = n_nudos * 2
K = np.zeros((n_gdl, n_gdl))
for i in range(n_tramos):
L, EI = longitudes[i], E[i] * I[i]
k_local = (EI / L**3) * np.array([[12, 6*L, -12, 6*L], [6*L, 4*L**2, -6*L, 2*L**2], [-12, -6*L, 12, -6*L], [6*L, 2*L**2, -6*L, 4*L**2]])
indices = np.array([2*i, 2*i+1, 2*i+2, 2*i+3])
K[np.ix_(indices, indices)] += k_local
F_applied = np.zeros(n_gdl)
F_fem_global = np.zeros(n_gdl)
for carga in cargas_dist:
tramo_idx, q1, q2 = carga[0]-1, carga[1], carga[2]
L = longitudes[tramo_idx]
F_fem_global[2*tramo_idx:2*(tramo_idx+1)+2] += np.array([(7*q1*L/20) + (3*q2*L/20), (q1*L**2/20) + (q2*L**2/30), (3*q1*L/20) + (7*q2*L/20), -(q1*L**2/30) - (q2*L**2/20)])
for carga in cargas_punt:
nudo, P, M = carga
F_applied[2*(nudo-1)] -= P
F_applied[2*(nudo-1)+1] += M
F_total_nodal = F_applied - F_fem_global
gdl_restringidos = [idx for n, rv, rg in apoyos for i, idx in enumerate([2*(n-1), 2*(n-1)+1]) if (i==0 and rv==1) or (i==1 and rg==1)]
gdl_libres = [i for i in range(n_gdl) if i not in gdl_restringidos]
K_reducida, F_reducido = K[np.ix_(gdl_libres, gdl_libres)], F_total_nodal[gdl_libres]
d = np.zeros(n_gdl)
if gdl_libres:
d[gdl_libres] = np.linalg.solve(K_reducida, F_reducido)
Reacciones = (K @ d) + F_fem_global - F_applied
fig, (ax1, ax_reac, ax2, ax3) = plt.subplots(4, 1, figsize=(12, 11), sharex=True, gridspec_kw={'height_ratios': [1.5, 1, 3, 3]})
nodos_pos = np.cumsum([0] + longitudes)
ax1.set_title('Diagrama de Cuerpo Libre')
ax1.axhline(0, color='black', lw=3)
for nudo, rest_v, rest_giro in apoyos:
x_pos = nodos_pos[nudo-1]
if rest_v == 1 and rest_giro == 1: draw_fixed_support(ax1, x_pos)
elif rest_v == 1: draw_pinned_support(ax1, x_pos)
for tramo, q1, q2 in cargas_dist:
x_start, x_end = nodos_pos[tramo-1], nodos_pos[tramo]
draw_distributed_load(ax1, x_start, x_end, q1, q2)
for nudo, P, M in cargas_punt:
x_pos = nodos_pos[nudo-1]
if P != 0: draw_point_load(ax1, x_pos, P)
ax1.set_ylim(-2, 4)
ax1.axis('off')
ax_reac.set_title('Diagrama de Reacciones')
ax_reac.axhline(0, color='black', lw=1.5, ls='--')
for nudo, rest_v, rest_giro in apoyos:
x_pos = nodos_pos[nudo-1]
if rest_v: draw_reaction_force(ax_reac, x_pos, Reacciones[2*(nudo-1)])
if rest_giro: draw_fancy_moment(ax_reac, x_pos, Reacciones[2*(nudo-1)+1])
ax_reac.set_ylim(-1.5, 1.5)
ax_reac.axis('off')
x_total, cortante_total, momento_total = [], [], []
for i in range(n_tramos):
L, EI = longitudes[i], E[i] * I[i]
d_local = d[2*i:2*i+4]
q1, q2 = next((c[1:] for c in cargas_dist if c[0] == i + 1), (0, 0))
k_local = (EI / L**3) * np.array([[12, 6*L, -12, 6*L], [6*L, 4*L**2, -6*L, 2*L**2], [-12, -6*L, 12, -6*L], [6*L, 2*L**2, -6*L, 4*L**2]])
f_fem_local = np.array([(7*q1*L/20)+(3*q2*L/20), (q1*L**2/20)+(q2*L**2/30), (3*q1*L/20)+(7*q2*L/20), -(q1*L**2/30)-(q2*L**2/20)])
f_internas = k_local @ d_local + f_fem_local
V1, M1 = f_internas[0], f_internas[1]
x_tramo = np.linspace(0, L, 50)
V = V1 - q1*x_tramo - (q2-q1)*(x_tramo**2)/(2*L)
M = -M1 + V1*x_tramo - (q1*x_tramo**2/2) - (q2-q1)*(x_tramo**3)/(6*L)
x_total.extend(x_tramo + nodos_pos[i])
cortante_total.extend(V)
momento_total.extend(M)
ax2.plot(x_total, cortante_total, 'r-')
ax2.fill_between(x_total, cortante_total, color='red', alpha=0.3)
ax2.set_title('Diagrama de Fuerza Cortante'); ax2.set_ylabel('Cortante'); ax2.grid(True)
ax3.plot(x_total, momento_total, 'b-')
ax3.fill_between(x_total, momento_total, color='blue', alpha=0.3)
ax3.invert_yaxis()
ax3.set_title('Diagrama de Momento Flector'); ax3.set_xlabel('Posición'); ax3.set_ylabel('Momento'); ax3.grid(True)
plt.tight_layout()
plt.show()
# --- Ejemplo de uso 1 ---
longitudes_ej1 = [24, 4, 4]
E_ej1 = [1, 1, 1]
I_ej1 = [1, 1, 1]
cargas_dist_ej1 = [[1, 2, 2]]
cargas_punt_ej1 = [[3, 12, 0]]
apoyos_ej1 = [[1, 1, 1], [2, 1, 0], [4, 1, 0]]
print("Ejecutando el primer ejemplo del video:")
viga_rigidez(longitudes_ej1, E_ej1, I_ej1, cargas_dist_ej1, cargas_punt_ej1, apoyos_ej1)
# --- Ejemplo de uso 2 ---
longitudes_ej2 = [8, 6]
E_ej2 = [1, 1]
I_ej2 = [1, 1]
cargas_dist_ej2 = [[2, 0, 6]]
cargas_punt_ej2 = []
apoyos_ej2 = [[1, 1, 1], [2, 1, 0], [3, 1, 1]]
print("\nEjecutando el segundo ejemplo del video:")
viga_rigidez(longitudes_ej2, E_ej2, I_ej2, cargas_dist_ej2, cargas_punt_ej2, apoyos_ej2)
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import Polygon, FancyArrowPatch
# --- Funciones auxiliares para dibujar ---
def draw_fixed_support(ax, x_pos, scale=1.0):
"""Dibuja un apoyo empotrado en la posición x_pos."""
height = 0.5 * scale
ax.plot([x_pos, x_pos], [-height, height], 'k-', lw=2)
for y in np.linspace(-height, height, 7):
ax.plot([x_pos, x_pos - height/2], [y, y - height/2], 'k-')
def draw_pinned_support(ax, x_pos, scale=1.0):
"""Dibuja un apoyo fijo/móvil (triángulo) en la posición x_pos."""
height = 0.4 * scale
width = 0.25 * scale
triangle = Polygon([[x_pos, 0], [x_pos - width, -height], [x_pos + width, -height]], facecolor='lightgray', edgecolor='k')
ax.add_patch(triangle)
def draw_distributed_load(ax, x_start, x_end, q_start, q_end, scale=0.4):
"""Dibuja una carga distribuida (trapezoidal/triangular)."""
y_offset = 0.3
y_start_pos = y_offset + q_start * scale
y_end_pos = y_offset + q_end * scale
# Dibuja el contorno de la carga
ax.plot([x_start, x_end], [y_start_pos, y_end_pos], 'r-')
ax.plot([x_start, x_start], [y_offset, y_start_pos], 'r-')
ax.plot([x_end, x_end], [y_offset, y_end_pos], 'r-')
# Rellena el área
ax.fill_between([x_start, x_end], [y_start_pos, y_end_pos], y2=y_offset, color='red', alpha=0.3)
# Dibuja las flechas de la carga
for x_arrow in np.linspace(x_start, x_end, 10):
q_interp = q_start + (q_end - q_start) * (x_arrow - x_start) / (x_end - x_start)
# --- CONDICIÓN AÑADIDA ---
# Solo dibuja la flecha si la magnitud de la carga en ese punto es significativa (no es cero)
if q_interp > 1e-6:
ax.arrow(x_arrow, y_offset + q_interp*scale, 0, -q_interp*scale, head_width=0.3, head_length=0.1, fc='r', ec='r')
# --- FIN DE LA MODIFICACIÓN ---
ax.text((x_start+x_end)/2, y_offset + max(q_start, q_end)*scale + 0.2, f'{max(q_start,q_end)}', ha='center', color='black')
def draw_point_load(ax, x_pos, magnitude, scale=1.5):
"""Dibuja una carga puntual."""
y_offset = 0.3
ax.arrow(x_pos, y_offset + scale, 0, -scale, head_width=0.4, head_length=0.2, fc='r', ec='r', lw=1.5)
ax.text(x_pos, y_offset + scale + 0.2, f'{abs(magnitude)}', ha='center', color='black')
def draw_reaction_force(ax, x_pos, magnitude):
"""Dibuja una flecha de reacción de fuerza con texto claro."""
if abs(magnitude) < 1e-6: return
direction = np.sign(magnitude)
arrow_length = 0.6
ax.arrow(x_pos, 0, 0, arrow_length * direction, head_width=0.4, head_length=0.2, fc='purple', ec='purple', lw=1.5)
text_y_offset = 0.1 * direction
vertical_alignment = 'bottom' if direction > 0 else 'top'
ax.text(x_pos, (arrow_length * direction) + text_y_offset, f'{magnitude:.2f}', ha='center', va=vertical_alignment, color='purple')
def draw_fancy_moment(ax, x_pos, magnitude, scale=0.5, color='g', linestyle='--'):
"""Dibuja un momento curvo con estilo mejorado y texto sin solapamiento."""
if abs(magnitude) < 1e-6: return
if magnitude > 0: # Anti-horario (positivo)
start_pos, end_pos = (x_pos + scale, 0.05), (x_pos - scale, 0.05)
else: # Horario (negativo)
start_pos, end_pos = (x_pos - scale, 0.05), (x_pos + scale, 0.05)
arrow = FancyArrowPatch(start_pos, end_pos, connectionstyle=f"arc3,rad={0.8}", color=color,
arrowstyle='->,head_length=5,head_width=3', lw=1.5, ls=linestyle)
ax.add_patch(arrow)
# Desplaza horizontalmente el texto del momento para evitar colisiones
text_x_pos = x_pos + scale * 0.6
ax.text(text_x_pos, scale * 0.6, f'{magnitude:.2f}', ha='left', va='center', color=color)
# --- Función Principal ---
def viga_rigidez(longitudes, E, I, cargas_dist, cargas_punt, apoyos):
n_tramos = len(longitudes)
n_nudos = n_tramos + 1
n_gdl = n_nudos * 2
K = np.zeros((n_gdl, n_gdl))
for i in range(n_tramos):
L, EI = longitudes[i], E[i] * I[i]
k_local = (EI / L**3) * np.array([[12, 6*L, -12, 6*L], [6*L, 4*L**2, -6*L, 2*L**2], [-12, -6*L, 12, -6*L], [6*L, 2*L**2, -6*L, 4*L**2]])
indices = np.array([2*i, 2*i+1, 2*i+2, 2*i+3])
K[np.ix_(indices, indices)] += k_local
F_applied = np.zeros(n_gdl)
F_fem_global = np.zeros(n_gdl)
for carga in cargas_dist:
tramo_idx, q1, q2 = carga[0]-1, carga[1], carga[2]
L = longitudes[tramo_idx]
F_fem_global[2*tramo_idx:2*(tramo_idx+1)+2] += np.array([(7*q1*L/20) + (3*q2*L/20), (q1*L**2/20) + (q2*L**2/30), (3*q1*L/20) + (7*q2*L/20), -(q1*L**2/30) - (q2*L**2/20)])
for carga in cargas_punt:
nudo, P, M = carga
F_applied[2*(nudo-1)] -= P
F_applied[2*(nudo-1)+1] += M
F_total_nodal = F_applied - F_fem_global
gdl_restringidos = [idx for n, rv, rg in apoyos for i, idx in enumerate([2*(n-1), 2*(n-1)+1]) if (i==0 and rv==1) or (i==1 and rg==1)]
gdl_libres = [i for i in range(n_gdl) if i not in gdl_restringidos]
K_reducida, F_reducido = K[np.ix_(gdl_libres, gdl_libres)], F_total_nodal[gdl_libres]
d = np.zeros(n_gdl)
if gdl_libres:
d[gdl_libres] = np.linalg.solve(K_reducida, F_reducido)
Reacciones = (K @ d) + F_fem_global - F_applied
fig, (ax1, ax_reac, ax2, ax3) = plt.subplots(4, 1, figsize=(12, 11), sharex=True, gridspec_kw={'height_ratios': [1.5, 1, 3, 3]})
nodos_pos = np.cumsum([0] + longitudes)
ax1.set_title('Diagrama de Cuerpo Libre')
ax1.axhline(0, color='black', lw=3)
for nudo, rest_v, rest_giro in apoyos:
x_pos = nodos_pos[nudo-1]
if rest_v == 1 and rest_giro == 1: draw_fixed_support(ax1, x_pos)
elif rest_v == 1: draw_pinned_support(ax1, x_pos)
for tramo, q1, q2 in cargas_dist:
x_start, x_end = nodos_pos[tramo-1], nodos_pos[tramo]
draw_distributed_load(ax1, x_start, x_end, q1, q2)
for nudo, P, M in cargas_punt:
x_pos = nodos_pos[nudo-1]
if P != 0: draw_point_load(ax1, x_pos, P)
ax1.set_ylim(-2, 4)
ax1.axis('off')
ax_reac.set_title('Diagrama de Reacciones')
ax_reac.axhline(0, color='black', lw=1.5, ls='--')
for nudo, rest_v, rest_giro in apoyos:
x_pos = nodos_pos[nudo-1]
if rest_v: draw_reaction_force(ax_reac, x_pos, Reacciones[2*(nudo-1)])
if rest_giro: draw_fancy_moment(ax_reac, x_pos, Reacciones[2*(nudo-1)+1])
ax_reac.set_ylim(-1.5, 1.5)
ax_reac.axis('off')
x_total, cortante_total, momento_total = [], [], []
for i in range(n_tramos):
L, EI = longitudes[i], E[i] * I[i]
d_local = d[2*i:2*i+4]
q1, q2 = next((c[1:] for c in cargas_dist if c[0] == i + 1), (0, 0))
k_local = (EI / L**3) * np.array([[12, 6*L, -12, 6*L], [6*L, 4*L**2, -6*L, 2*L**2], [-12, -6*L, 12, -6*L], [6*L, 2*L**2, -6*L, 4*L**2]])
f_fem_local = np.array([(7*q1*L/20)+(3*q2*L/20), (q1*L**2/20)+(q2*L**2/30), (3*q1*L/20)+(7*q2*L/20), -(q1*L**2/30)-(q2*L**2/20)])
f_internas = k_local @ d_local + f_fem_local
V1, M1 = f_internas[0], f_internas[1]
x_tramo = np.linspace(0, L, 50)
V = V1 - q1*x_tramo - (q2-q1)*(x_tramo**2)/(2*L)
M = -M1 + V1*x_tramo - (q1*x_tramo**2/2) - (q2-q1)*(x_tramo**3)/(6*L)
x_total.extend(x_tramo + nodos_pos[i])
cortante_total.extend(V)
momento_total.extend(M)
ax2.plot(x_total, cortante_total, 'r-')
ax2.fill_between(x_total, cortante_total, color='red', alpha=0.3)
ax2.set_title('Diagrama de Fuerza Cortante'); ax2.set_ylabel('Cortante'); ax2.grid(True)
ax3.plot(x_total, momento_total, 'b-')
ax3.fill_between(x_total, momento_total, color='blue', alpha=0.3)
ax3.invert_yaxis()
ax3.set_title('Diagrama de Momento Flector'); ax3.set_xlabel('Posición'); ax3.set_ylabel('Momento'); ax3.grid(True)
plt.tight_layout()
plt.show()
# --- Ejemplo de uso 1 ---
longitudes_ej1 = [24, 4, 4]
E_ej1 = [1, 1, 1]
I_ej1 = [1, 1, 1]
cargas_dist_ej1 = [[1, 2, 2]]
cargas_punt_ej1 = [[3, 12, 0]]
apoyos_ej1 = [[1, 1, 1], [2, 1, 0], [4, 1, 0]]
print("Ejecutando el primer ejemplo del video:")
viga_rigidez(longitudes_ej1, E_ej1, I_ej1, cargas_dist_ej1, cargas_punt_ej1, apoyos_ej1)
# --- Ejemplo de uso 2 ---
longitudes_ej2 = [8, 6]
E_ej2 = [1, 1]
I_ej2 = [1, 1]
cargas_dist_ej2 = [[2, 0, 6]]
cargas_punt_ej2 = []
apoyos_ej2 = [[1, 1, 1], [2, 1, 0], [3, 1, 1]]
print("\nEjecutando el segundo ejemplo del video:")
viga_rigidez(longitudes_ej2, E_ej2, I_ej2, cargas_dist_ej2, cargas_punt_ej2, apoyos_ej2)
with st.spinner("Realizando cálculos..."):
reticulate::repl_python()
View(kd_matrix_interp)
setwd("~/01 APPs_Web_Adolfo/AD_caumax")
